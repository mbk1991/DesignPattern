-디자인패턴(Design Pattern)
프로그램 개발 시 문제 해결을 위한 개발자들의 경험, 내적인 축적을
디자인 패턴이라는 형태로 정의하고 이름을 붙였다.
이를 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
4인의 개발자(GoF, The Gang of Four)가 
정리하여
Elements of Reusable Object-Oriented Software 
라는 책으로 발간하였다.
GoF가 정의한 23개의 디자인 패턴을 Java언어로 다루어본다.

-디자인 패턴의 용어를 빌리면 보다 용이하게 서로의 아이디어를 비교, 논의할 수 있다.
-매일 사용하는 프로그램을 새로운 시점에서 다시 생각하고, 재사용을 쉽게하고, 기능확장이
쉬운 소프트웨어를 만들기 위한 유익한 기법이 디자인 패턴이다.

-디자인 패턴에서 클래스 및 인스턴스의 관계 표현을 위해 UML(Unified Modeling Language)을 사용한다.
-클래스다이어그램에서 화살표의 방향. 화살표는 아는 것을 지목한다, 즉 자식이 부모를 가리킨다.
-클래스다이어그램은 정적, 시퀀스다이어그램은 동적
-다이어그램은 보는 것이 아니라 읽는 것이다.

▷Iterator패턴
-반복자, 루프변수와 같은 역할을 한다.
-Aggregate 인터페이스는 집합체를 나타낸다. like 배열
-클래스를 집합체로 다루기 위해 Aggregate 인터페이스를 구현시킨다.
-Iterator 인터페이스는 hasNext() next() 추상메소드를 정의
-Aggregate 인터페이스는 iterator() 추상메소드를 정의


-ConcreteIterator는 구체적인 순회 방법에 대한 알고리즘을 정한다. 
-ConcreteAggregate는 ConcreteIterator를 만든다.

-그냥 배열을 돌리면 되는데 왜 Iterator패턴을 쓰느냐? 구현에서 분리하기 위하여.
실제 java.util.Iterator 라이브러리에서 Iterator패턴을 활용하고 있다.

-다형성을 이용할 때 구현클래스, 상속클래스에만 정의한 메소드는 부모타입, 인터페이스타입에서 사용을 못한다.

-배열이든, ArrayList든 요소를 순회하면서 각각의 요소에 대해 처리를 해야할 일이 있다.
-배열이든 ArrayList든 여러 요소의 집합체(Aggregate)의 요소를 특정한 순회 방법에 따라
순회하며 각각의 요소에 대해 처리를 해야할 일이 있다.

집합체와 '순회' 를 분리하여 특정 Aggregate에 의존하지 않는 것이다.

클라이언트 단에서는
Iterator인터페이스의 hasNext()와 next()만 이용하지만

내부적으로는 구상 반복자, 구상 컬렉션에 따라 컬렉션과 순회법을 달리할 수 있다.


▷Adapter패턴 Wrapper패턴

-클라이언트가 무언가 할 때 A라는 방식을 사용한다.
-'무언가 유용한 기능'을 사용하려는데 이것은 B라는 방식으로만 사용할 수 있다.
-클라이언트가 A라는 방식을 고수하면서 B방식으로 동작하는 '무언가 유용한 기능'을 사용하려면 어떻게 해야할까?
-B방식을 A방식으로 수정하여야 할까? 이미 완성되어 있는 '무언가 유용한 기능'을 변경시키는 것은 좋지 않다.
-B방식을 A방식으로 포장한다면? 겉으로는 A방식으로 동작하게 된다.
-A방식 내부에서 B방식이 실행된다면?  A방식이지만 내부에서는 B방식을 실행시킨다.
-이미 구현되어 있는 기능을 클라이언트가 사용하는 방식에 맞춰 사용할 수 있도록 중간에서 변환시켜주는 것을 Adapter라고 한다.
-구방식을 고집하는 클라이언트인데 구방식 내부에서 신방식을 동작시킨다면, 겉으로는 구방식이지만 실제로는 신방식을 사용할 수 있다.
-Adapter패턴을 활용하면 클라이언트가 동작하는 방식은 변경하지 않고, 다양한 방식으로 동작하는 버전들을 클라이언트의 방식으로 포장시켜 동작시킬 수 있다.
-Adapter패턴은 구상을 추상으로 감싸거나, 내부 동작을 위임시켜 구현한다.
-Adapter패턴은 이미 만들어진 클래스를 새로운 인터페이스에 맞게 개조시키는 것이다.
-Adapter패턴은 이미 만들어진 클래스를 전혀 수정하지 않고 사용중인 인터페이스에 맞추는 것이다.

-Adapter패턴은 2가지 방식이 있다. 
-클라이언트가 인터페이스의 기능을 이용하고 있을 때에는 확장과 구현을 통해 Adapter를 구현한다.(인터페이스이므로 다중 상속)

-클라이언트가 클래스의 기능을 이용하고 있을 때에는 확장과 위임을 통해 Adapter를 구현한다.(Adapter가 두 클래스를 다중 상속 받을 수 없으므로) 


▷Template Method패턴
-템플릿은 정해진 형태를 만드는 틀이다.
-템플릿을 통해 형태를 만들 때 재료는 다양하게 바꿔볼 수 있다.
-템플릿 역할을 하는 '템플릿메소드'를 만들어 사용하는 패턴이 Template Method 패턴이다.
-템플릿 메소드로 공통된 흐름, 뼈대를 정의하고 내부적인 동작은 구상에 맡긴다.
-상위 클래스에서 템플릿 메소드를 정의한다.
-템플릿 메소드 내에는 추상 메소드들로 공통된 로직, 흐름, 뼈대를 잡아 놓았다.
-템플릿 메소드 내의 추상메소드의 구체적인 기능은 하위 클래스에서 정한다.
-상위 클래스의 템플릿 메소드에서 흐름을 정하고 하위 클래스에서는 흐름 속의 구체적인 처리를 결정한다.
-공통적인 특정 흐름, 뼈대를 가지는 기능 A,B,C를 만들어야 할 때 완성된 A기능을 복사하여 B와 C기능을 만들고
각각 다르게 구현할 부분만 수정을 한다면 어떨까? 
-공통된 흐름에 대한 부분이 중복되고 수정 및 유지 보수 시 A,B,C코드를 모두 변경하여야 한다. 
-특정 로직으로 동작할 메소드를 템플릿 메소드로 정의하고 세부적인 내용은 하위 클래스에서 정하는 패턴인 것이다.


▷Factory Method패턴


-템플릿메소드 패턴으로 인스턴스를 생성하는 패턴이 팩토리메소드패턴이다.
-인스턴스 생성을 템플릿메소드 패턴으로 수행하는 방법이다.
-인스턴스를 생성해주는 객체를 Factory라고 표현한다.
-인스턴스 생성 방법과 인스턴스를 생성할 클래스를 분리하는 것이다.
-팩토리는 인스턴스를 만든다.
-상위클래스에서 인스턴스 생성방법( 인스턴스 생성을 위한 공통된 로직, 흐름, 뼈대 ) 를 템플릿메소드패턴으로 정의한다.
-하위클래스에서 특정 인스턴스를 생성하기 위한 구체적인 방법을 작성한다.

-subclass responsibility 대처 방법
1) 추상메소드
2) 디폴트 준비
3) 상위에서 예외던지기


▷Singleton 패턴


▷Prototype 패턴

-Java에서 인스턴스를 생성하는 방법
-new 연산자로 클래스 이름을 지정하여 생성하는 방법
-인스턴스를 복사해서 생성하는 방법 -> Prototype 패턴
-"원래의 서류를 어떻게 만들었는지는 몰라도 복사기로 서류의 복사본을 만들 수 있다"
-"원래의 객체를 어떻게 만들었는지는 몰라도 clone()으로 객체의 복사본을 만들 수 있다"
-Java에서는 Cloneable을 implements한 클래스는 Object의 clone() 메소드를 사용할 수 있다.
-clone()메소드를 사용하면 인스턴스 자기 자신에 대한 복사체 (필드 값 포함) 를 만들어 반환한다.
-클래스의 이름을 몰라도 clone()메소드로 자기 자신의 인스턴스를 만들 수 있다.
-Cloneable 인터페이스를 implements한 인터페이스의 구상클래스들은 모두 자기 자신의 복사체를 만들어
 반환할 수 있다.
- obj = clone(); 이면 자기 자신의 복사체를 obj에 담을 수 있는 것
-Prototype 인터페이스는 createClone() 추상메소드를 정의한다.
-Prototype의 구상클래스는 createClone() 메소드를 오버라이드하고 자기 자신의 복사본을 반환한다.

왜쓰는거지

-복잡한 작업을 거쳐서 생성하는 인스턴스는 저장해두었다가 필요할 때 복사해서 사용한다.
-관리할 인스턴스의 종류가 너무 많아 클래스로 정리되지 않는경우 (?) 사용한다.
-인스턴스 생성 소스를 특정 클래스에 의존하지 않도록 만들기 위해 사용한다.


▷Builder패턴
-객체를 생성하는 디자인 패턴
-복잡한 객체를 단계별로 생성해나가는 패턴
-객체 생성을 단계별로 빌드업 해나간다.
-객체 생성방법에는 점층적 생성자패턴, 자바빈즈패턴, 필더 패턴이 존재한다.
-구조를 가진 인스턴스를 쌓아올리는 패턴이다.
-Builder는 객체 생성 단계(절차) 에 대한 추상메소드를 정의한다. ex) 인스턴스 생성을 위한 절차 step1, step2, step3
-Builder가 정의한 추상메소드는 각각의 하위 클래스에서 구체화한다.
-Director는 Builder의 메소드를 이용하여 인스턴스(객체) 를 조립(구축)한다

-빌더는 자신의 클래스에서 객체 생성에 대한 코드를 추출한다. 
-빌더는 객체 제작 단계별 방법을 구현한다.
-디렉터는 빌더의 방법을 가지고 단계별로 객체를 조립한다.

-빌더패턴에 항상 디렉터가 있지는 않다. 하지만 빌더의 방법을 가지고 다양한 객체 생성 루틴을 가지고 있는 디렉터가 있다면 편리하다.

-다양한 빌더들은 다양한 방식으로 같은 작업을 실행한다.

-수많은 필드와 중첩된 객체를 힘들게 단계별로 초기화해야 하는 복잡한 객체가 있을 때
초기화 코드는 수많은 매개변수를 가진 거대한 생성자 내부에 묻혀 있을 수 있다. - 모든 매개변수가 다 필요하지 않다.
또는 초기화 코드가 클라이언트 코드전체에 흩어져있을 수 있다.


-점층적 생성자패턴은 메소드 오버로딩을 지원하는 Java나 C#같은 언어에서만 가능하다.
-매개변수가 다양한 여러개의 생성자를 사용하는 점층적 생성자 패턴을 빌더패턴으로 바꿀 수 있다.

-공통 생성 단계를 명확하게 정의해야 한다.

-SRP. 복잡한 객체 생성 코드를 분리한다.

-팩토리메소드로 시작해 빌더패턴, 추상팩토리패턴, 프로토타입패턴으로 발전한다.

-빌더패턴은 복잡한 객체의 단계별 생성에 주안점
-추상팩토리 패턴은 관련객체 패밀리 생성에 주안점

-StringBuilder에서 사용한다!?



▷Abstract Factory  패턴

-제품군(패밀리)를 생성하는 패턴이다.
-추상적인 팩토리는 추상적인 부품으로 추상적인 제품을 만든다.
-클라이언트는 추상적인 팩토리의 기능을 사용한다.
-클라이언트는 추상적인 팩토리에 대입되는 구체적인 팩토리에 해당하는 제품군을 생성할 수 있다.
-Class 클래스의 forName메소드로 클래스를 동적으로 읽을 수 있다.


▷Bridge패턴
-하위 클래스를 만들 때 상위 클래스의 기능을 '확장' 할수도 있고 상위클래스의 인터페이스를 '구현' 할 수도 있다.
-하위클래스에서 기능을 추가하는 것과 상위클래스의 기능을 구현하려는 것이 혼재되면 클래스 계층을 복잡하게 한다.
-클래스 계층이란 상위클래스(부모)와 하위클래스(자식)의 계층을 말한다.
-기능을 추가하는(확장하는) 클래스 계층을 '기능의 클래스 계층'이라 할 수 있다.
-상위 클래스의 기능을 구현하는 클래스 계층을 '구현의 클래스 계층'이라 할 수 있다.
-기능의 클래스 계층에서는 구현의 클래스 계층에서 최상위 클래스 타입을 전달 받아 사용한다.
-구현을 나타내는 클래스의 인스턴스를 필드에 저장하여 사용하는데, 이 필드가 기능의 클래스 계층과 구현의 클래스 계층의'다리(Bridge)'이다.
-기능의 클래스 계층과 구현의 클래스 계층, 즉 기능계층과 구현계층을 분리해두면 확장이 편리해진다.
-기능을 추가하기 위하여 구현 계층을 수정할 필요가 전혀 없다.
-기능 계층에 새롭게 추가한 기능은 '모든 구현'에서 이용할 수 있다.
-상속(Inheritance) 는 강한 연결이고 위임(Delegation)은 약한 연결이다.
-상속은 SuperClass extends SubClass 와 같이 '소스 코드' 로서 강하게 명시되어 있기 때문에 이 관계를 끊기 위해서는 소스 코드를 바꾸어 주어야 한다.
-위임은 주입받기에 따라 클래스 간의 관계를 척척 바꾸기 편리하다.


▷Strategy패턴
- 프로그래밍에서 strategy = 전략 = 알고리즘
- 같은 문제를 다른 방법으로 해결하기 위한 '알고리즘 교체 전략' 이 Strategy패턴이다.
- 가위바위보를 이기기 위한 전략을 전략A, 전략B, 전략C... 등의 방법으로 교체한다.
- 보통은 알고리즘이 메소드 내부에 녹아 있는 경우가 많다.
- 알고리즘을 의식적으로 분리하고 알고리즘에 대한 인터페이스(API)를 규정한다.
- 규정한 알고리즘 인터페이스를 위임하여 이용한다.
- 위임이라는 느슨한 연결을 사용하여 알고리즘을 용이하게 교체할 수 있다.
- strategy 패턴에서 위임을 사용하여 런타임 중 전략을 교체할 수 있다.(동적인 교체) 
- 전략을 위임하는 곳을 교환하는 패턴이다.


▷Composite패턴
-그릇과 내용물을 동일시해서 재귀적인 구조를 만들기 위한 디자인 패턴이다.
-composite는 복합체라는 뜻
-내용물과 내용물을 담고 있는 복합체를 동일시 한다.
-여러개를 모아서 마치 하나인 것처럼 취급할 수 있다.(재귀적)
-복수와 단수를 동일시한다.
-내용물과 복합체를 동일시하는 역할을 컴포넌트역할이라고 칭한다.
-컴포넌트는 내용물과 복합체의 공통적인 작업을 정한다.
-내용물을 Leaf라고 칭한다.
-재귀적 구조로 내용물 계층을 타고 들어간다.
-예를 들면 파일과 디렉토리를 동일시하여 다루는 것이다.
-내용물과 복합체를 동일시 하지만 복합체에서만 사용가능한 메소드가 있을 수 있고 내용물과 복합체에서 다르게 동작하여야 하는 메소드가 있다.
-특정 하위 클래스에서만 사용할 수 있는 메소드를 구현하는 방법으로는 컴포넌트(상위클래스)에서 해당 메소드를 예외처리하고 메소드를
사용할 클래스에서 의미 있는 구현으로 Override하는 방법이 있다.
-컴포넌트(상위 클래스) 에서 해당 메소드에 아무 것도 구현하지 않는 방법도 있다. 이 경우 해당 메소드를 사용하기 위해 구현한 자식 클래스가 아닌 경우 메소드를 실행하여도 아무 일도 일어나지 않는다.
-트리 구조의 데이터 구조는 일반적으로 Composite패턴으로 다룬다.
-자바에서는 this와 문자열을 더하면 자동적으로 해당 오브젝트의 toString()으 호출한다.


▷Decorator 패턴
-기본 오브젝트(객체)를 목적에 맞게 꾸며나가는 패턴이다.
-decorate는 꾸미다, 장식이라는 뜻
-장식과 내용물을 동일시한다.
-장식과 내용물이 동일한 메소드를 가진다.
-같은 메소드를 가진다는 것은 인터페이스(API)적으로 동일시 할 수 있다는 의미이다.
-데코레이터는 장식과 내용물을 동일시한다.
-장식에 둘러싸인 내용물이 내용물 그 자체가 될 수 있다.
-꾸민 내용물 그 자체를 또 내용물로 사용할 수 있다.
-재귀적 구조를 취하는 점이 Composite패턴과 유사하지만 Decorator패턴은 기능을 추가해가는 것에 주안점을 둔다.
-java.io패키지에서 데코레이터 패턴을 사용하고 있다. LineNumberReader, BufferedReader등 보조스트림이 그렇다.
-유사한 성질의 작은 클래스가 많이 만들어진다는 단점이 있다.



▷Visitor패턴
-Visitor는 방문자이다.
-기존 데이터 구조에 대한 수정을 최소화하고 기능을 확장하고자 할 때 사용한다. (OCP)
-확장하고자 하는 새로운 기능을 기존 클래스가 아닌 Visitor라는 별도의 클래스에서 처리한다.
-Visitor는 데이터 구조에 방문하면서 특정 처리를 하는 역할을 한다.
-데이터 구조와 처리를 분리하는 것이다.
-데이터 구조에서는 Visitor의 방문을 받아들일 수 있어야 한다.
-예제에서 Element인터페이스의 구현은, Visitor를 받아들일 수 있음을 나타낸다.
-Visitor가 방문해서 방문하는 곳의 this를 가져옴. Visitor의 구현 클래스에서는 방문해서 가져온 this의 메소드를
위임해서 처리할 것으로 보인다. 방문자가 집 안에 들어와서 리모콘을 가져다가 집 안의 기능을 동작시킴..
-방문자 승낙, 방문자에게 자기자신(this)을 위임한다. 방문자는 위임받은 노드의 메소드를 활용하여 기능을
수행한다. 
-방문자가 노드의 하위 노드를 순회하며 처리할 수 있도록 노드에서는 iterator()를 반환하는 메소드를 구현한다.
- 두 개의 메소드가 서로를 호출하는 더블 디스패치(Double Dispatch, 이중 분리) 구조이다.
-Composit패턴으로 구조와 기본 기능이 완성되어 있다. 여기서 각 노드들에
새로운 기능을 추가(확장)하고자 한다. 각각의 노드 (복합체 또는 Leaf) 에 대한
수정을 최소화 하면서 기능은 확장하고자 한다.(OCP) 이 때 노드의 구조와 처리(기능)를
분리하는 VIsitor패턴을 이용하면 가능하다.


▷Chain of Responsibility 패턴
-책임자를 줄지어 놓고, 앞의 책임자부터 할 수 있으면 처리하고 못하면 뒤로 넘기는 패턴이다.
-클라이언트는 최초의 책임자에게만 요청한다. 요청 사항은 처리할 수 있는 책임자가 처리한다.
-끝까지 뒤로 넘겨도 처리할 수 있는 책임자가 없으면 예외처리 등을 한다.
-요청 시 어떤 책임자에게 맡길지까지 클라이언트가 결정하는 것은 '어떤 업무를 어떤 책임자에게 맡길지'
책임자의 업무까지 클라이언트가 알고 있어야 함을 의미한다.
-동적으로 chan의 형태를 바꿀 수 있다.


▷Facade패턴


*jvm, static 조사

-간단한 창구 역할
-뒷 단의 로직은 복잡하지만 이것만 호출하면 OK가 되는 인터페이스
-Facade는 건물의 '정면' 이라는 뜻이다.
-프로그램은 점점 커지고 복잡해지고 메소드를 정확하게 순서대로 호출할 필요가 있다. 이 복잡한 과정을
앞단의 단순한 인터페이스가 처리해준다.
-높은 레벨에서 단순한 인터페이스를 외부에 제공한다.
-파싸드의 인터페이스는 되도록 적게 하는 것이 좋다.
-클래스를 지나치게 외부로 노출하는 것은 좋지 않다.
-파싸드 패턴을 더 큰 단위에서 재귀적으로 적용할 수 있다.
-상당히 큰 시스템의 요소요소에 파싸드 패턴을 적용하면 시스템이 편리해진다.
-★확실하게 언어로 표현할 수 있는 노하우는 프로그래머의 머리 속에 숨겨둘 것이 아니라 코드로 표현해야 한다.



▷Mediator 패턴
-Mediator를 중개인, 중개가 필요한 각 회원을 Colleague라고 칭한다.
-여러 객체(회원)이 서로 통신을 주고 받으며 서로의 상태에 대해 영향을 주고 특정 기능을 구현해야할 때
기능은 객체 중 어디에 구현해야 할까?
-다수의 오브젝트가 서로 통신을 하지 않고 중개인하고만 통신을 하는 것이 중개자 패턴이다.
-다수의 오브젝트의 상호작용을 기반으로 동작하는 기능은 중개자가 구현한다.
-중개자는 모든 회원을 가지고 있다.
-각각의 회원은 중개자를 가지고 있다.
-중개자는 한 회원의 상태에 따라 다른 회원의 동작을 구현할 수 있다.

▷Observer패턴
-Observer는 관찰자이다.
-Publish/ Subscrib 패턴이라고도 한다.
-관찰되는 대상을 Subject라고 칭한다.
-Observer는 Subject의 동작 및 상태 변화를 관찰하고 동작을 수행한다.
-하지만 사실은 Observer는 능동적으로 관찰하는 것이아니라 Subject에게 알림을 받는다.
-Subject가  동작 및 상태 변화 시 본인이 가지고 있는 Observe에게 이를 알린다.
-Observer는 Subject가 Observer를 update할 때(변화를 알릴 때) 동작한다.
-Subject는 여러 Observer를 가지고 있을 수 있다.
-'상태 변화를 알린다'는 점에서 Mediator패턴과 비슷하지만 Mediator는 여러 오브젝트들의 보고를 받아 해당 오브젝트들(Colleague)을 컨트롤하고, Observer는 Subject가 여러 Observer를 가지고 Observer들에게 상태변화를 알리면 각각의 Observer가 로직을 수행한다.
-Subject는 본인이 사용할 Observer를 추가하고 삭제할 수 있다.
-Subject는 현재의 상태를 취득하는 메소드를 가지고 있다.
-Observer가Subject의 상태를 변화시킬 경우 메소드 호출이 반복될 수 있다. 이 경우 플래그 변수를 사용하는 것이 좋다.
-Subject가 어느 정보까지 Observer에게 알릴 지는 프로그램의 복잡성을 고려해서 설계한다.
-Observer패턴은 Subject의 변화를 Observer에게 알려서 상태를 동기화 하는 일에 주안점을 둔다.
-Mediator패턴은 Colleague들의 변화를 가지고 Colleague들을 조정하는데 주안점을 준다.


?자바의 클래스는 왜 다중 상속이 안되고
인터페이스는 다중 상속이 될까????!


▷Memento 패턴

-Memento는 '기억하기 위한 기념품' 을 뜻한다.
-스냅샷 사진 처럼 특정 시점의 객체 상태를 Memento로 저장하고, 필요 시  그 상태로 돌아간다.
-Ctrl + Z 처럼 undo 기능을 수행하기 위해 사용한다.
-Memento 생성이 필요한 원본을 Original이라고 칭한다.
-Original은 현재 본인의 상태(데이터)와 같은 Memento를 생성하고, memento를 이용하여 본인의 상태를 변경하는 기능을 수행할 수 있다.
-Memento는 Original의 상태(데이터)를 저장할 수 있는 객체이다.
-언제 Oritinal의 메멘토를 저장할지, 언제 Original을 저장된 메멘토로 undo할지 정하는 역할을 Caretaker(관리인)이라고 칭한다.



▷State 패턴

-State는 상태를 의미한다
-상태를 클래스로 표현하는 방법이다.
-특정 기능이 상태에 따라 달라질 때 사용한다.
-State패턴을 사용하지 않으면 각각의 기능을 수행하는 메소드 내부에 상태에 따라 다르게 동작하는
분기를 만들게 된다.
-State패턴을 이용하면 각각의 구체적인 상태를 나타내는 클래스는 해당 상태에서 수행할 기능만 구현하면 된다. 
-State 패턴을 사용하는 맥락이 되는 클래스를 Context라 칭한다.
-Context는 State의 필드를 가진다
-Context가 가지고 있는 State 필드에 대입되는 구체적 State가 전환되는 것을 <상태전환> 이라 칭한다.
-상태전환을 각각의 구체적 State에서 하는 것과 Context에서 하는 것에는 장단점이 있다.
-상태전환을 위해 Mediator 패턴을 적용하는 것이 좋을 수 있다.
-각각의 구체적 State는 
-State패턴을 사용하면 메소드 안에 묻혀있는 상태에 대한 분기를 외부로 표현하게 된다.
-State는 상태에 의존한 처리를 하는 메소드의 집합이다.
-각각의 State는 싱글톤 패턴으로 생성하여 메모리 낭비를 방지한다. 
-Divide and Conquer 방침에 부합한다. 각각의 상태를 분리하여 각각의 상태가 처리할 내용을 작성한다.


