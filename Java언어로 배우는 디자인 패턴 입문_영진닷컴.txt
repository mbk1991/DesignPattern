-디자인패턴(Design Pattern)
프로그램 개발 시 문제 해결을 위한 개발자들의 경험, 내적인 축적을
디자인 패턴이라는 형태로 정의하고 이름을 붙였다.
이를 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
4인의 개발자(GoF, The Gang of Four)가 
정리하여
Elements of Reusable Object-Oriented Software 
라는 책으로 발간하였다.
GoF가 정의한 23개의 디자인 패턴을 Java언어로 다루어본다.

-디자인 패턴의 용어를 빌리면 보다 용이하게 서로의 아이디어를 비교, 논의할 수 있다.
-매일 사용하는 프로그램을 새로운 시점에서 다시 생각하고, 재사용을 쉽게하고, 기능확장이
쉬운 소프트웨어를 만들기 위한 유익한 기법이 디자인 패턴이다.

-디자인 패턴에서 클래스 및 인스턴스의 관계 표현을 위해 UML(Unified Modeling Language)을 사용한다.
-클래스다이어그램에서 화살표의 방향. 화살표는 아는 것을 지목한다, 즉 자식이 부모를 가리킨다.
-클래스다이어그램은 정적, 시퀀스다이어그램은 동적
-다이어그램은 보는 것이 아니라 읽는 것이다.

▷Iterator패턴
-반복자, 루프변수와 같은 역할을 한다.
-Aggregate 인터페이스는 집합체를 나타낸다. like 배열
-클래스를 집합체로 다루기 위해 Aggregate 인터페이스를 구현시킨다.
-Iterator 인터페이스는 hasNext() next() 추상메소드를 정의
-Aggregate 인터페이스는 iterator() 추상메소드를 정의


-ConcreteIterator는 구체적인 순회 방법에 대한 알고리즘을 정한다. 
-ConcreteAggregate는 ConcreteIterator를 만든다.

-그냥 배열을 돌리면 되는데 왜 Iterator패턴을 쓰느냐? 구현에서 분리하기 위하여.
실제 java.util.Iterator 라이브러리에서 Iterator패턴을 활용하고 있다.

-다형성을 이용할 때 구현클래스, 상속클래스에만 정의한 메소드는 부모타입, 인터페이스타입에서 사용을 못한다.

-배열이든, ArrayList든 요소를 순회하면서 각각의 요소에 대해 처리를 해야할 일이 있다.
-배열이든 ArrayList든 여러 요소의 집합체(Aggregate)의 요소를 특정한 순회 방법에 따라
순회하며 각각의 요소에 대해 처리를 해야할 일이 있다.

집합체와 '순회' 를 분리하여 특정 Aggregate에 의존하지 않는 것이다.

클라이언트 단에서는
Iterator인터페이스의 hasNext()와 next()만 이용하지만

내부적으로는 구상 반복자, 구상 컬렉션에 따라 컬렉션과 순회법을 달리할 수 있다.


▷Adapter패턴 Wrapper패턴

-클라이언트가 무언가 할 때 A라는 방식을 사용한다.
-'무언가 유용한 기능'을 사용하려는데 이것은 B라는 방식으로만 사용할 수 있다.
-클라이언트가 A라는 방식을 고수하면서 B방식으로 동작하는 '무언가 유용한 기능'을 사용하려면 어떻게 해야할까?
-B방식을 A방식으로 수정하여야 할까? 이미 완성되어 있는 '무언가 유용한 기능'을 변경시키는 것은 좋지 않다.
-B방식을 A방식으로 포장한다면? 겉으로는 A방식으로 동작하게 된다.
-A방식 내부에서 B방식이 실행된다면?  A방식이지만 내부에서는 B방식을 실행시킨다.
-이미 구현되어 있는 기능을 클라이언트가 사용하는 방식에 맞춰 사용할 수 있도록 중간에서 변환시켜주는 것을 Adapter라고 한다.
-구방식을 고집하는 클라이언트인데 구방식 내부에서 신방식을 동작시킨다면, 겉으로는 구방식이지만 실제로는 신방식을 사용할 수 있다.
-Adapter패턴을 활용하면 클라이언트가 동작하는 방식은 변경하지 않고, 다양한 방식으로 동작하는 버전들을 클라이언트의 방식으로 포장시켜 동작시킬 수 있다.
-Adapter패턴은 구상을 추상으로 감싸거나, 내부 동작을 위임시켜 구현한다.
-Adapter패턴은 이미 만들어진 클래스를 새로운 인터페이스에 맞게 개조시키는 것이다.
-Adapter패턴은 이미 만들어진 클래스를 전혀 수정하지 않고 사용중인 인터페이스에 맞추는 것이다.

-Adapter패턴은 2가지 방식이 있다. 
-클라이언트가 인터페이스의 기능을 이용하고 있을 때에는 확장과 구현을 통해 Adapter를 구현한다.(인터페이스이므로 다중 상속)

-클라이언트가 클래스의 기능을 이용하고 있을 때에는 확장과 위임을 통해 Adapter를 구현한다.(Adapter가 두 클래스를 다중 상속 받을 수 없으므로) 


▷Template Method패턴
-템플릿은 정해진 형태를 만드는 틀이다.
-템플릿을 통해 형태를 만들 때 재료는 다양하게 바꿔볼 수 있다.
-템플릿 역할을 하는 '템플릿메소드'를 만들어 사용하는 패턴이 Template Method 패턴이다.
-템플릿 메소드로 공통된 흐름, 뼈대를 정의하고 내부적인 동작은 구상에 맡긴다.
-상위 클래스에서 템플릿 메소드를 정의한다.
-템플릿 메소드 내에는 추상 메소드들로 공통된 로직, 흐름, 뼈대를 잡아 놓았다.
-템플릿 메소드 내의 추상메소드의 구체적인 기능은 하위 클래스에서 정한다.
-상위 클래스의 템플릿 메소드에서 흐름을 정하고 하위 클래스에서는 흐름 속의 구체적인 처리를 결정한다.
-공통적인 특정 흐름, 뼈대를 가지는 기능 A,B,C를 만들어야 할 때 완성된 A기능을 복사하여 B와 C기능을 만들고
각각 다르게 구현할 부분만 수정을 한다면 어떨까? 
-공통된 흐름에 대한 부분이 중복되고 수정 및 유지 보수 시 A,B,C코드를 모두 변경하여야 한다. 
-특정 로직으로 동작할 메소드를 템플릿 메소드로 정의하고 세부적인 내용은 하위 클래스에서 정하는 패턴인 것이다.


▷Factory Method패턴


-템플릿메소드 패턴으로 인스턴스를 생성하는 패턴이 팩토리메소드패턴이다.
-인스턴스 생성을 템플릿메소드 패턴으로 수행하는 방법이다.
-인스턴스를 생성해주는 객체를 Factory라고 표현한다.
-인스턴스 생성 방법과 인스턴스를 생성할 클래스를 분리하는 것이다.
-팩토리는 인스턴스를 만든다.
-상위클래스에서 인스턴스 생성방법( 인스턴스 생성을 위한 공통된 로직, 흐름, 뼈대 ) 를 템플릿메소드패턴으로 정의한다.
-하위클래스에서 특정 인스턴스를 생성하기 위한 구체적인 방법을 작성한다.

-subclass responsibility 대처 방법
1) 추상메소드
2) 디폴트 준비
3) 상위에서 예외던지기






